buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.netflix.nebula:gradle-aggregate-javadocs-plugin:2.2.+'
        classpath 'org.ajoberstar:gradle-git-publish:0.2.1'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
    }
}

def depVersions = [
        commercetoolsSdkJvm: '1.8.0', // 1.16.0
        assertJ: '3.4.1', // 3.6.2
        mockito: '1.9.5', // 2.7.22'
        junit: '4.12',
        slf4j: '1.7.25'
]

// dev version patch. Real version should be specified as Java property
ext.versionWIP = 'dev-WIP-version'

allprojects {
    repositories {
        jcenter()
        mavenCentral()
    }

    apply plugin: 'java'

    group = 'com.commercetools.payment'

    // version should be defined from runtime property, e.g. should be passed to the build like -Dbuild.version=$TRAVIS_TAG
    version = System.getProperty('build.version')?: versionWIP

    description "The commercetools java payment project intend is to make payment integration easy"

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }
}

subprojects {

    apply plugin: 'maven'
    apply plugin: 'maven-publish'

    // this is an important plugin for maven/bintray publishing to avoid "all dependencies are runtime scope":
    // see https://github.com/bintray/gradle-bintray-plugin#maven-publications and https://github.com/gradle/gradle/issues/1118
    apply plugin: 'java-library'

    apply plugin: 'com.jfrog.bintray'

    // package sources and javadoc to jar
    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        from javadoc.destinationDir
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    install.dependsOn build

    // library bintray/maven publish settings
    def pomConfig = {
        licenses {
            license {
                name "The Apache Software License, Version 2.0"
                url "http://www.apache.org/licenses/LICENSE-2.0.txt"
                distribution "repo"
            }
        }
        developers {
            developer {
                id 'andrii-kovalenko-ct'
                name 'Andrii Kovalenko'
                url 'https://github.com/andrii-kovalenko-ct'
                email 'andrii.kovalenko@commercetools.com'
            }
            developer {
                id 'ahalberkamp'
                name 'Andreas Halberkamp'
                url 'https://github.com/ahalberkamp'
                email 'andreas.halberkamp@commercetools.de'
            }
            developer {
                id 'MGA-dotSource'
                name 'Mirco'
                url 'https://github.com/MGA-dotSource'
            }
            developer {
                id 'mht-dotsource'
                name 'Martin Horatschek'
                url  'https://github.com/mht-dotsource'
            }
        }
    }

    // maven-specific publishing settings
    publishing {
        publications {
            paymentPublication(MavenPublication) {
                from components.java

                artifact sourcesJar
                artifact javadocJar

                groupId rootProject.group
                artifactId project.name
                version rootProject.version

                pom.withXml {
                    def root = asNode()
                    root.appendNode('description', 'The commercetools java payment project intend is to make payment integration easy')
                    root.appendNode('name', "$project.name")
                    root.appendNode('url', 'https://github.com/commercetools/project-payment.git')
                    root.children().last() + pomConfig
                }
            }
        }
    }

    // bintray-specific upload configuration
    bintray {
        user = project.hasProperty('bintrayUser') ? project.property('bintrayUser') : System.getenv('BINTRAY_USER')
        key = project.hasProperty('bintrayKey') ? project.property('bintrayKey') : System.getenv('BINTRAY_KEY')

        publications = ['paymentPublication']

        pkg {
            // see https://bintray.com/commercetools/maven/ settings
            repo = 'maven'
            userOrg = bintray.user
            name = 'payment'
            licenses = ['Apache-2.0']
            vcsUrl = 'https://github.com/commercetools/project-payment.git'

            publicDownloadNumbers = true

            version {
                name = rootProject.version
                released  = new Date()
                //desc =
                //vcsTag =
                //attributes = []
            }
        }
    }

    // validate values before bintray upload starting
    bintrayUpload {
        doFirst {
            // validate credentials before trying to upload to bintray
            // this check is mandatory because of "bintrayUpload silently fails" issue of the plugin
            // https://github.com/bintray/gradle-bintray-plugin/issues/170
            if (!(bintray.user?.trim() && bintray.key?.trim())) {
                throw new InvalidUserDataException('Bintray User or Key is not set. ' +
                        'Validate BINTRAY_USER and BINTRAY_KEY environment variables. ' +
                        'Or use -DbintrayUser and -DbintrayKey java runtime properties')
            }

            validateVersion('Bintray upload could be performed only with valid release version')
        }
    }
}

project(':common') {
    description "Common API interfaces and methods for $rootProject.name"

    dependencies {
        compile "com.commercetools.sdk.jvm.core:commercetools-models:$depVersions.commercetoolsSdkJvm"
        compile "com.commercetools.sdk.jvm.core:commercetools-java-client:$depVersions.commercetoolsSdkJvm"

        testCompile "junit:junit:$depVersions.junit"
        testCompile "org.assertj:assertj-core:$depVersions.assertJ"
        testCompile "org.mockito:mockito-core:$depVersions.mockito"
    }
}

project(':nopsp-adapter') {
    description "Simple mock payment implementation (\"free-to-pay\") for $rootProject.name"

    dependencies {
        compile project(':common')
    }
}

project(':payone-adapter') {
    description "Implementation of Payone PSP specific methods and transactions."

    dependencies {
        compile project(':common')

        testCompile "junit:junit:$depVersions.junit"
        testCompile "org.assertj:assertj-core:$depVersions.assertJ"
        testCompile "org.mockito:mockito-core:$depVersions.mockito"
    }
}

project(':') {

    description "Unit and Integration tests to verify $rootProject.name build"

    // aggregate all javadocs to project.buildDir/docs/javadoc
    // see https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin
    apply plugin: 'nebula-aggregate-javadocs'
    apply plugin: 'org.ajoberstar.git-publish'

    // Integration tests configuration
    // TODO: carry out to a separate sub-project or task

    dependencies {
        compile project(':common'), project(':nopsp-adapter'), project(':payone-adapter')

        testCompile "junit:junit:$depVersions.junit"
        testCompile "org.assertj:assertj-core:$depVersions.assertJ"
        testCompile "org.slf4j:slf4j-simple:$depVersions.slf4j"
    }

    // run the integration tests after all other subtasks
    configure(subprojects) {
        rootProject.compileJava.mustRunAfter.add(it.build)
    }

    sourceSets {
        integrationTest {
            java {
                //compileClasspath += main.output + test.output
                //runtimeClasspath += main.output + test.output
                srcDir file('src/it/') // TODO: move to src/it/java, or even better to integration-test/src/it/java
            }
            resources.srcDir file('src/it/resources')
        }
    }

    configurations {
        integrationTestCompile.extendsFrom testCompile
        integrationTestRuntime.extendsFrom testRuntime
    }

    task integrationTest(type: Test) {
        testClassesDir = sourceSets.integrationTest.output.classesDir
        classpath = sourceSets.integrationTest.runtimeClasspath
        //outputs.upToDateWhen { false } // uncommect this section if you want re-run the tests every build, even when no changes have been done
    }

    check.dependsOn integrationTest
    integrationTest.mustRunAfter test

    final javadocVersionPath = 'javadoc/v'

    // publish aggregated javadoc to the repo, https://github.com/ajoberstar/gradle-git-publish
    gitPublish {
        // NOTE: $GRGIT_USER environment variable must be set to actual github token
        // see http://ajoberstar.org/grgit/docs/groovydoc/index.html?org/ajoberstar/grgit/auth/AuthConfig.html
        // https://github.com/ajoberstar/grgit#usage

        repoUri = 'https://github.com/commercetools/project-payment.git'
        branch = 'gh-pages'

        contents {
            from(javadoc) {
                // every version has it's own javadoc subdirectory
                into "$javadocVersionPath/$rootProject.version"
            }
        }

        preserve {
            include "$javadocVersionPath/**" // don't remove previous javadoc versions
            exclude "$javadocVersionPath/$versionWIP" // but remove temporary WIP javadoc if any
        }

        commitMessage = "Publishing a new java doc for $rootProject.version version"
    }

    gitPublishReset {
        doFirst {
            // try to find github publish token in the next order:
            // 1) -Dorg.ajoberstar.grgit.auth.username
            // 2) $GRGIT_USER
            // 3) $GH_TOKEN
            // interrupt the task if neither of them is set.
            if (!System.getProperty('org.ajoberstar.grgit.auth.username')?.trim()) {
                def githubToken = System.getProperty('org.ajoberstar.grgit.auth.username') ?:
                            (System.getenv('GRGIT_USER') ?:
                                    System.getenv('GH_TOKEN'))

                if (!githubToken?.trim()) {
                    throw new InvalidUserDataException('For github publish GRGIT_USER or GH_TOKEN environment variable ' +
                            'or org.ajoberstar.grgit.auth.username Java runtime property must be set')
                }

                System.setProperty('org.ajoberstar.grgit.auth.username', githubToken)
            }

            validateVersion('Documentation publishing could be performed only with a valid release version')
        }
    }

    gitPublishPush {
        doLast {
            println "Published javadoc to https://commercetools.github.io/project-payment/$javadocVersionPath/$rootProject.version"
        }
    }
}

void validateVersion(String prefix) throws InvalidUserDataException {
    // validate version is set and not a default version
    if (!rootProject.version?.trim() || rootProject.version == versionWIP) {
        throw new InvalidUserDataException(prefix +
                "$prefix.\nPls, specify -Dbuild.version=<version-name> as the build argument.\n" +
                "Current version is \"$rootProject.version\"")
    }
}
